## 半同步半反应堆线程池类详解

### 服务器编程基本框架

虽然服务器程序种类繁多，但是基本框架都一样，不同之处在于逻辑处理。

![服务器框架图](D:\cpp_learning\myTinyWebserver\threadpool\服务器框架图.png)

|     模块     |       单个服务器程序       |          服务器集群          |
| :----------: | :------------------------: | :--------------------------: |
| I/O处理单元  | 处理客户连接，读写网络数据 | 作为接入服务器，实现负载均衡 |
|   逻辑单元   |       业务进程或线程       |          逻辑服务器          |
| 网络存储单元 |   本地数据库、文件或缓存   |         数据库服务器         |
|   请求队列   |    各单元之间的通信方式    |  各服务器之间的永久TCP连接   |

### 五种IO模型

- **阻塞IO**:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。
- **非阻塞IO**:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管时间是否已经发生，若时间没有发生，则返回-1，此时可以根据errno区分这两种情况，对于accept，recv和send，事件未发生时，errno通常被设置成eagain。
- **信号驱动IO**:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。
- **IO复用**:linux用**select/poll/epoll**函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数
- **异步IO**:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。

**注意：阻塞I/O，非阻塞I/O，信号驱动I/O和I/O复用都是同步I/O。同步I/O指内核向应用程序通知的是就绪事件，比如只通知有客户端连接，要求用户代码自行执行I/O操作，异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序，由内核完成I/O操作。**

### 事件处理模式

- **reactor模式**：主线程(**I/O处理单元**)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(**逻辑单元** )，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由**同步I/O**实现。

**使用同步I/O模型(以 epoll 为例) 实现的 Reator 模式的工作流程：**

1. 主线程向 epoll 内核事件表中注册 socket 上的读就绪事件；
2. 主线程调用 epoll_wait 等待 socket 上有数据可读；
3. 当 socket 上有数据可读时，epoll_wait 通知主线程，主线程则将 socket 可读事件放入请求队列；
4. 睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户端请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件；
5. 主线程调用 epoll_wait 等待 socket 可写；
6. 当socket可写时， epoll_wait 通知主线程，主线程将 socket 可写事件放入请求队列；
7. 睡眠在请求队列上的某个工作线程被唤醒，它从 socket 上写入服务器处理客户端请求的结果。

![Reactor模式](D:\cpp_learning\myTinyWebserver\threadpool\Reactor模式.png)

- **proactor模式**：主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由**异步I/O**实现。**由于异步I/O并不成熟，实际中使用较少，这里将使用同步I/O模拟实现proactor模式。**

**同步I/O模型的工作流程如下（epoll_wait为例）：**

1. 主线程往epoll内核事件表注册socket上的读就绪事件。
2. 主线程调用epoll_wait等待socket上有数据可读
3. 当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。
4. 睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
5. 主线程调用epoll_wait等待socket可写。
6. 当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

![同步IO实现Proactor模式](D:\cpp_learning\myTinyWebserver\threadpool\同步IO实现Proactor模式.png)

### 并发模式

- **半同步/半异步模式**：同步线程用于处理客户逻辑，异步线程用于处理IO事件
- **领导者/追随者模式**

### 半同步/半反应堆模式

**半同步/半反应堆并发模式**是**半同步/半异步**的变体，将半异步具体化为某种事件处理模式。异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中请求队列将通知某个工作在**同步模式的工作线程**来读取并处理该请求对象。

**半同步/半反应堆工作流程（以Proactor模式为例）**

- 主线程充当异步线程，负责监听所有socket上的事件
- 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
- 如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中
- 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

### 线程池

- 空间换时间，浪费服务器的硬件资源，换取运行效率；
- 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源；
- 当服务器进入正式运行阶段，开始处理客户请求的时候,如果它需要相关的资源，可以直接从池中获取，无需动态分配；
- 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。

#### 静态成员变量

将类成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。

静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。

- 最好是类内声明，类外初始化（以免类名访问静态成员访问不到）。
- 无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限。
- 非静态成员类外不能初始化。
- 静态成员数据是共享的。

#### 静态成员函数

将类成员函数声明为static，则为静态成员函数。

- 静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问。
- 普通成员函数可以访问普通成员变量，也可以访问静态成员变量。
- 静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。

#### **pthread_create函数的陷阱**

函数原型：

```c++
#include <pthread.h>
int pthread_create (pthread_t *thread_tid,              //返回新生成的线程的id
                    const pthread_attr_t *attr,         //指向线程属性的指针,通常设置为NULL
                    void * (*start_routine) (void *),   //处理线程函数的地址
                    void *arg);                         //start_routine()中的参数
```

函数原型中的第三个参数，为函数指针，指向处理线程函数的地址。该函数，要求为静态函数。如果处理线程函数为类成员函数时，需要将其设置为**静态成员函数**。

**Remark：**pthread_create的函数原型中第三个参数的类型为函数指针，指向的线程处理函数参数类型为`(void *)`,若线程函数为类成员函数，则this指针会作为默认的参数被传进函数中，从而和线程函数参数`(void*)`不能匹配，不能通过编译。静态成员函数就没有这个问题，里面没有this指针。

#### **线程池类定义**

```c++
#ifndef THREADPOOL_H
#define THREADPOOL_H

#include <list>
#include <iostream>
#include <exception>
#include <pthread.h>

template <typename T>
class threadpool {
public:
    /*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/
    threadpool(int actor_model, connection_pool* connpool, int thread_number = 8, int max_request = 10000);
    ~threadpool();
    bool append(T* request, int state); // 请求队列中插入任务请求
    bool append_p(T* request);

private:
    static void* worker(void* arg);
    void run();

private:
    int m_thread_number;         // 线程池中的线程数
    int m_max_request;           // 请求队列中允许的最大请求数
    pthread_t* m_threads;        // 线程池的线程id数组，大小为m_thread_number
    std::list<T*> m_workqueue;   // 请求队列
    locker m_queuelocker;        // 保护请求队列的互斥锁
    sem m_queuestat              // 是否有任务需要处理
    connection_pool* m_connPool; // 数据库连接池
    int m_actor_model;           // 模型切换
};
#endif
```

